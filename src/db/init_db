Drop database if exists spsr_lt_db;
Create database spsr_lt_db;

create table Shops
(
	ID serial primary key,
	Name text not null,
	Description text not null
);

create table SaleReceipts
(
	ID serial primary key,
	FIO text not null,
	ShopID integer not null,
	DateOfPurchase date not null,
	foreign key (ShopID) references Shops(ID) on delete cascade
);

create table Products
(
	ID serial primary key,
	Name text not null,
	ProductType text not null
);

create table Availability
(
	ID serial primary key,
	ShopID integer not null,
	ProductID integer not null,
	foreign key (ShopID) references Shops(ID) on delete cascade,
	foreign key (ProductID) references Products(ID) on delete cascade
);

create table SaleReceiptPositions
(
	ID serial primary key,
	AvailabilityID integer not null,
	SaleReceiptID integer not null,
	foreign key (AvailabilityID) references Availability(ID) on delete cascade,
	foreign key (SaleReceiptID) references SaleReceipts(ID) on delete cascade
);

create table CostStory
(
	ID serial primary key,
	Year integer not null,
	Month integer not null,
	Cost integer not null,
	AvailabilityID integer not null,
	foreign key (AvailabilityID) references Availability(ID) on delete cascade
);

create view Costs as
	select AvailabilityID, Cost
	from CostStory
	where make_date(Year, Month, 1) in (select max(make_date(Year, Month, 1))
										from CostStory
										group by AvailabilityID);

-- Триггерная функция, которая удаляет значение цены товара в магазине если она старше новой на более 18 месяцев
create or replace function remove_too_old_coststory()
returns trigger
as $$
declare
	old_date_id integer;
	old_date date;
	new_date_id integer;
	new_date date;
	months_diff integer;
begin
-- Самое старое значение цены товара
	select min(date(prod_coststory.Year, prod_coststory.Month)) into old_date
	from (select * 
		  from CostStory 
		  where AvailabilityID = NEW.AvailabilityID) as prod_coststory;
	select prod_coststory.id into old_date_id
	from (select * 
		  from CostStory 
		  where AvailabilityID = NEW.AvailabilityID) as prod_coststory
	where date(prod_coststory.Year, prod_coststory.Month) = old_date;

-- Самое новое значение цены товара
	select max(date(prod_coststory.Year, prod_coststory.Month)) into new_date
	from (select * 
		  from CostStory 
		  where AvailabilityID = NEW.AvailabilityID) as prod_coststory;
	select prod_coststory.id into new_date_id
	from (select * 
		  from CostStory 
		  where AvailabilityID = NEW.AvailabilityID) as prod_coststory
	where date(prod_coststory.Year, prod_coststory.Month) = new_date;
	
	select (date_part('year', new_date) - date_part('year', old_date)) * 12 + (date_part('month', new_date) - date_part('month', old_date))
	into months_diff;
	
	if months_diff > 18 then
		delete from CostStory where AvailabilityID = NEW.AvailabilityID and ID = old_date_id;
	end if;
end
$$ language plpgsql;

create trigger update_coststory after insert on CostStory
	execute function remove_too_old_coststory();

create user "user";
grant connect on database spsr_lt_db to "user";
grant usage on schema public to "user";
grant select on table Shops, Products, Availability, Costs to "user";

create user "analyst" with password 'analyst';
grant connect on database spsr_lt_db to "analyst";
grant usage on schema public to "analyst";
grant select on table Shops, Products, Availability, CostStory to "analyst";

create user "admin" with password 'admin';
grant connect on database spsr_lt_db to "admin";
grant usage on schema public to "admin";
grant select, insert, update, delete on all tables in schema public to "admin";

drop user if exists "user";
drop user if exists "analyst";
drop user if exists "admin";

create or replace function get_products_by_shopid(shopid integer)
returns table(ProdName text, ProdType text, Cost integer)
as $$
begin
	select ProductID, Name, ProductType, Cost
	from ((select * from Availability where Availability.ShopID = shopid) as A 
			join Products on A.ProductID = Product.ID) as AP join Costs on AP.ID = Costs.AvailabilityID;
end
$$ language plpgsql;

create or replace function get_coststory_by_shopid_prodid(shopid integer, prodid integer)
returns table(Year integer, Month integer, Cost integer)
as $$
begin
	select Year, Month, Cost
	from CostStory
	where AvailabilityID = (select ID
						   from Availability
						   where ShopID = shopid and ProductID = prodid);
end
$$ language plpgsql;

create or replace function get_salereceipts_by_shopid(shopid integer)
returns table(FIO text, DateOfPurchase date, SummaryCost integer)
as $$
begin
	select max(FIO), max(DateOfPurchase), sum(Cost) as SummaryCost
	from ((select * from SaleReceipts where ShopID = shopid) as SR join SaleReceiptPositions on SaleReceiptPositions.SaleReceiptID = SR.ID) as S join Costs on S.AvailabilityID = Costs.AvailabilityID
	group by SaleReceipts.ID;
end
$$ language plpgsql;
